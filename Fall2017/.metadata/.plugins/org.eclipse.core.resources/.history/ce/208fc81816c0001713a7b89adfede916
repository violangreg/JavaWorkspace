import java.util.Random;

/*
 * Implementation of a singly linked list 
 * Commit your file into the SVN (Not BeachBoard)
 * Please do NOT modify the class names.
*/
public class LinkedList<E> {
	private class ListNode<E> {
		public E data;
		public ListNode<E> next;
	}
	
	private ListNode<E> head;
	private int size;
		
	public LinkedList() {		
		size = 0;
	}
	
	public int size() {
		return size + 1;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("LinkedList [");
		for (int i = 0; i <= size; i++) {
			sb.append(this.get(i));
			if (i != size) sb.append(", ");
		}
		sb.append("]");
		return sb.toString();
	}
	
/*
 1. Implement the methods add(E e), add(int i, E e), get(int index), remove(int index), and remove(E e) - 3 pts each
 You should update size after adding and removing an element.
*/
	// source used for add(e), push(e), add(i,e), get(i): http://www.geeksforgeeks.org/data-structures/linked-list/#singlyLinkedList
	/**
	 * Appends the specified element to the end of this list
	 * @param e - element to be appended to this list
	 */	 
	public void add(E e) {
		// create a new node to add to the list
		ListNode<E> new_node = new ListNode<E>();
		new_node.data = e;
		new_node.next = null;
		if(head == null){
			head = new_node;
			return;
		}
		// starting from the head node, crawl to the end of the list
		ListNode<E> last = head;
		while(last.next != null){
			last = last.next;
		}
		last.next = new_node;
		size++;
		return;
	}

	/**
	 * Inserts the specified element at the specified position in this list 
	 * @param i - index at which the specified element is to be inserted
	 * @param e - element to be inserted
	 */
	public void add(int i, E e) {
		// check index bounds
		if(index_outOfBounds(i)) 
			return;
		// just push to the front if i = 0
		if(i == 0) {
			push(e); // look below for push method
		}
		// push to the end if is the end
		else if(i == (size()-1)){
			add(e);
		}
		// if not, find node thats currently in that index and replace it, push the previous node back
		else{
			ListNode<E> prev_node = head;
			prev_node = getPrevNode(i);
			ListNode<E> new_node = new ListNode<E>();
			new_node.data = e;
			new_node.next = prev_node.next;
			prev_node.next = new_node;
			size++;
		}
	}

	/**
	 * Returns the element at the specified position in this list.
	 * @param index - index of the element to return
	 * @return the element at the specified position in this list
	 */
	public E get(int index) {
		// check index bounds
		if(index_outOfBounds(index))
			return null;
		
        ListNode<E> current = head;
        int count = 0;
        while (current != null)
        {
            if (count == index)
                break;
            count++;
            current = current.next;
        }
 
        return current.data;
	}	
	
	/**
	 * Removes the element at the specified position in this list
	 * @param index - the index of the element to be removed
	 * @return the element previously at the specified position
	 */
	public E remove(int index) {
		if(index_outOfBounds(index))
			return null;
		ListNode<E> prev_node = getPrevNode(index);
		
		return null;
	}
	
	/**
	 * Removes the first occurrence of the specified element from this list, if it is present
	 * @param e - element to be removed from this list, if present
	 * @return true if this list contained the specified element
	 */
	public boolean remove(E e) {
		ListNode<E> temp = head, prev = null;
		if(temp != null && temp.data == e){
			head = temp.next;
			size--;
			return true;
		}
		while(temp != null && temp.data != e){
			prev = temp;
			temp = temp.next;
		}
		if(temp == null)
			return false;
		
		prev.next = temp.next;
		
		size--;
		return true;
	}

/*
 *** O(1) space complexity ***
2. Reverse the list - 10 pts
	The space (not time) complexity should be O(1). 
	Write a program that reverses the order of the nodes.
	1 -> 2 -> 3 -> 4 
		==> 4 -> 3 -> 2 -> 1  
 */
	public void reverse() {

	}
		
/*
 *** O(1) space complexity ***
3. Remove duplicates - 10 pts
	The space (not time) complexity should be O(1).
	Write a program that removes duplicates.
	1 -> 4 -> 2 -> 4 -> 3
		==> 1 -> 4 -> 2 -> 3
 */
	public void trim() {
		
	}
	
/*
4. (Extra) Partition the list - 10 pts
 	Write a program to partition the list around a value x such that all nodes less than x come before all nodes greater than of equal to x.
 	2 -> 9 -> 8 -> 3 -> 4 -> 7 [x = 5]
 	 	==> 2 -> 3 -> 4 -> 9 -> 8 -> 7
 */
	public void partition(int x) {
		
	}
	
	// EXTRA CUSTOM METHODS
	/**
	 * Pushes the specified element to the front of this list
	 * @param e - element to be pushed to this list
	 */
	public void push(E e){
		// push a new node to the front of the list, time complexity O(1)
		ListNode<E> new_node = new ListNode<E>();
		new_node.data = e;
		new_node.next = head;
		head = new_node;
		size++;
	}
	// gets the previous node of a given index 
	public ListNode<E> getPrevNode(int i){
		if(index_outOfBounds(i)) 
			return null;
		ListNode<E> prev_node = head;
		for(int k = 0; k < i-1; k++)
			prev_node = prev_node.next;
		return prev_node;
	}
	/**
	 * Check for index bounds < 0 and > size
	 * @param index - index of the element to check
	 * @return false or true depending if the index is in bounds or not
	 */
	public boolean index_outOfBounds(int index){
		if(index > size + 1 || index < 0) {
			System.out.println("invalid index size: max is " + size()); 
			assert(false);
			return true;
		}
		return false;
	}
	
	public static void main(String[] args) {		
		LinkedList<Integer> sort_numbers = new LinkedList<Integer>();
		LinkedList<String> strings = new LinkedList<String>();
		for (int i = 0; i < 10; i++) {
			sort_numbers.add(i);			
		}
		for(int i = 0; i < 5; i++){
			strings.add("hello");
		}
		System.out.println(strings.remove("why"));
		System.out.println(strings.toString());
		System.out.println(sort_numbers.size());
		System.out.println(sort_numbers.toString());
		sort_numbers.reverse();
		System.out.println("Reverse: " + sort_numbers);
		
		Random rand = new Random();
		LinkedList<Integer> rand_numbers = new LinkedList<Integer>();
		for (int i = 0; i < 20; i++) {
			rand_numbers.add(rand.nextInt(10));			
		}
		rand_numbers.trim();
		System.out.println("Trim: " + rand_numbers);
		
		rand_numbers.partition(5);
		System.out.println("Partition: " + rand_numbers);
	}
}
